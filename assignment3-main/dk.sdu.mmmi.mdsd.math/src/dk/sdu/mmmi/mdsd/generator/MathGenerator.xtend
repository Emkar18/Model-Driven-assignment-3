/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.LetBinding
import dk.sdu.mmmi.mdsd.math.MathNumber
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.VarBinding
import dk.sdu.mmmi.mdsd.math.VariableUse
import java.util.HashMap
import java.util.Map
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.MathExp
import dk.sdu.mmmi.mdsd.math.ParenthesisExp
import dk.sdu.mmmi.mdsd.math.Expression

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {
	
	static Map<String, String> variables;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		variables = new HashMap();
		val exp = resource.allContents.filter(MathExp).next
		fsa.generateFile("math_expression/"+exp.name+".java",'''
		package math_expression;
					
			public class «exp.name»{
				«FOR binding : exp.variables»
					public int «binding.name»;
				«ENDFOR»
				
				public void compute() {
					«FOR binding : exp.variables»
						«IF binding.expression instanceof LetBinding»
							«computeLetExpression(binding.expression as LetBinding) »
						«ENDIF»
						«binding.name» = «binding.expression.computeExpression»;
						«variables.put(binding.name, binding.expression.computeExpression)»
					«ENDFOR»
				}
			}
		''')
	}
	
	def static String computeLetExpression(LetBinding binding) {
		if (!variables.containsKey(binding.name)){
			"int " + binding.name + ";\n" +
			binding.name + " = " + binding.binding.computeExpression() + ";\n"
		} else {
			binding.name + " = " + binding.binding.computeExpression() + ";\n"
		}
	}
		
	def static dispatch String computeExpression(MathNumber exp) {
		exp.value.toString()
	}
	
	def static dispatch String computeExpression(ParenthesisExp exp) {
		"(" + exp.expression.computeExpression + ")"
	}
	
	def static dispatch String computeExpression(Plus exp) {
		exp.left.computeExpression + "+" + exp.right.computeExpression
	}

	def static dispatch String computeExpression(Minus exp) {
		exp.left.computeExpression +"-"+ exp.right.computeExpression
	}
	
	def static dispatch String computeExpression(Mult exp) {
		exp.left.computeExpression +"*"+ exp.right.computeExpression
	}
	
	def static dispatch String computeExpression(Div exp) {
		exp.left.computeExpression +"/"+ exp.right.computeExpression
	}
	
	def static dispatch String computeExpression(VariableUse exp) {
		exp.ref.computeBinding
	}
	
	def static dispatch String computeBinding(VarBinding binding){
		if(!variables.containsKey(binding.name))
			binding.computeExpression			
		binding.name
	}
	
	def static dispatch String computeBinding(LetBinding binding){
		binding.name
	}

	def static dispatch String computeExpression(LetBinding exp) {
		exp.body.computeExpression
	}
	
	def static dispatch String computeExpression(VarBinding binding) {
		variables.put(binding.name, binding.expression.computeExpression.toString())
		return variables.get(binding.name)
	}
}
